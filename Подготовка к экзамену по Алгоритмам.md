1. Первая лекция Github
```Python
def f_me(x):
    if isinstance(x, (int, float)) and abs(x) < float("inf"):
        return x * 25 + 10
    return None
```
   
2. Фибоначчи
```python
def fib(n):
    if n == None or n == 0 or n == "abc" or n == float("-inf") or n == float("inf") or n < 0:
        return None
    if n == 1:
         return 0
    if n == 2 or n == 3:
         return 1
    
    fib1 = fib2 = 1

    for _ in range(3, n):
            fib1 , fib2 = fib2, fib1 + fib2
            
    return fib2
```

**Плюсы алгоритма:**

- простота; 
- возможность использовать в различных вычислениях, анализе алгоритмов, структурах данных и сортировке. 

**Минусы алгоритма:**

- большое количество избыточных вычислений, что делает его неэффективным для больших входных данных. 

3.  Одна из сортировок
``` python
def sort(a):
	n = len(a)
	for i in range(n):
		for j in range(0, n-i-1):
			if a[j] > a[j+1]:
				a[j], a[j+1] = a[j+1], a[j]
return a
```

4. Таблица сортировок

|      Сортировка      |                     Время                      |                      +                       |             -              |
| :------------------: | :--------------------------------------------: | :------------------------------------------: | :------------------------: |
|  Сортировка выбором  |                    $О(n^2)$                    |        Занимает 1 (константу) памяти         | Медленный,<br>Нестабильный |
|  Быстрая сортировка  | $О(n*log(n))$<br><br>В худшем случае: $O(n^2)$ |    Занимает $n*log(n)$ памяти,<br>Быстрый    |        Нестабильный        |
| Сортировка пузырьком |    $О(n^2)$<br><br>В лучшем случае: $О(n)$     | Занимает 1 (константу) памяти,<br>Стабильный |         Медленный          |
|   Сортировка кучей   |                 $О(n*log(n))$                  |  Занимает 1 (константу) памяти,<br>Быстрый   |        Нестабильный        |
| Сортировка вставками |    $O(n^2)$<br><br>В лучшем случае: $О(n)$     | Занимает 1 (константу) памяти,<br>Стабильный |         Медленный          |
| Сортировка слиянием  |                 $О(n*log(n))$                  |            Быстрый,<br>Стабильный            |     Занимает n памяти      |

5. Бинарный поиск
```Python
def binary_search(list, item):
    low = 0
    high = len(list) - 1
    while low <= high:
        mid = int((low + high) / 2)
        guess = list[mid]
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None


my_list = [1, 3, 5, 7, 9]

print (binary_search(my_list, 3))
print (binary_search(my_list, -1))
```

**Особенности:**
	1. Список исходных данных обязательно должен быть отсортирован.
	2. Бинарный поиск может быть использован для нахождения чисел, строк, объектов и любых других сущностей, которые можно сравнивать между собой
	3. Преимущество использования заключается не только в эффективности, но и в возможности применения на различных уровнях сложности данных.

6. Способы представления графа в памяти компьютера 
	1. **Матрица смежности**. Это матрица, где по строкам и столбцам располагаются номера вершин. Если ребро между вершинами отсутствует, то на пересечении i-ой строки и j-ого столбца ставится 0, если ребро есть, то ставят 1 
	   **Применение**: С её помощью можно найти кратчайшие пути между вершинами, построить минимальные остовы и т. д..
	2. **Матрица инцидентности**. По столбцам располагаются рёбра, а по строкам номера вершин. На пересечении i-ой вершины и j-ого ребра ставится 1, если одним из концов ребра j была вершина i. 
	   **Применение:** Её используют, если количество рёбер невелико. Например, для хранения электрической схемы, в которой вершины — элементы схемы, а дуги — соединяющие провода. 
	3. **Список смежности**.  Это набор списков по числу вершин в графе. Каждый список представляет из себя перечисление всех смежных данной вершине. 
	   **Применение:** Его применяют для решения проблемы расширяемости графа, так как новые узлы и дуги могут быть очень просто и эффективно добавлены во время выполнения программы.
	4. **Список рёбер**.  Он представляет собой перечисление всех рёбер графа. 
	   **Применение:** Его используют, если из матрицы инцидентности убрать все нули, в каждом столбце останется только два числа для каждого ребра — номера инцидентных ему вершин.

7. Сложности алгоритмов
	 **Сложность алгоритма** — это количественная характеристика, которая говорит о том, сколько времени либо какой объём памяти потребуется для выполнения алгоритма. 

	Обычно у алгоритмов бывает две сложности:

	1. **Временная сложность** — как количество операций, которые выполняются при работе алгоритма, связано с объёмом входных данных. 
	2. **Сложность по памяти** — как количество памяти, которое нужно алгоритму, связано с размером входных данных. 
	**Примеры оценок сложности алгоритмов:**

	- **O(1)** — константная сложность, время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу. 
	- **O(log n)** — логарифмическая сложность, время выполнения алгоритма растёт медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве. 
	- **O(n)** — линейная сложность, время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве. 
	- **O(n log n)** — линейно-логарифмическая сложность, время выполнения алгоритма растёт быстрее, чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).
	- **O(n^2)** — квадратичная сложность, время выполнения алгоритма зависит от квадрата размера входных данных. Например, сортировка пузырьком (bubble sort). 

	Знание сложности алгоритмов позволяет оптимизировать функциональность приложений и обеспечить пользователям быстрый и удобный поиск. 

8. Рекурсия
	**Рекурсия** — это поведение функции, при котором она вызывает сама себя. Такие функции называются рекурсивными. В отличие от цикла, они не просто повторяются несколько раз, а работают «внутри» друг друга. 
	**Рекурсия нужна, когда требуется выполнить последовательность из одинаковых действий**. Прописывать их все слишком долго, а иногда невозможно, потому что неизвестно, сколько действий понадобится.
	**Если забыть прописать условие выхода, рекурсия будет выполняться бесконечно** — программу придётся завершать принудительно.

9. Основные структуры данных и их свойства (в контексте python)
	1. **Список (List)**. Это упорядоченная коллекция данных, в качестве элементов в ней могут выступать объекты любых других типов. Доступ к элементам списка можно получить по индексу. 
	2. **Кортеж (Tuple)**. Похож на список, но неизменяем, то есть элементы в нём нельзя изменить после создания. Как и список, кортеж может содержать элементы различных типов.
	3. **Словарь (Dictionary)**. Это неупорядоченная коллекция данных, хранящихся в формате пары ключ:значение. Индексация словаря Python осуществляется с помощью ключей. Это может быть любой хэшируемый тип данных: строки, числа, кортежи и т. д..
	4. **Множество (Set)**. Это изменяемый набор из уникальных элементов. Множества используются в основном для нахождения общих элементов и устранения дубликатов.
	5. **Строка (String)**. Это неизменяемый массив байтов, представляющих собой набор символов в Unicode.

10.  Задача о рюкзаке
```python
from collections import namedtuple
from functools import lru_cache

Item = namedtuple('Item', 'value weight')
items = Item(4, 5), Item(3, 4), Item(3, 2), Item(2, 1)
capacity = 6  # max weight we can put into the knapsack

 def knapsack(items, capacity): 
    result = [] 
	    def best_value(nitems, weight_limit): 
		    if nitems == 0: 
			    return 0 
		    elif items[nitems - 1].weight > weight_limit: 
			    return best_value(nitems - 1, weight_limit)
			 else: 
				 return max(best_value(nitems - 1, weight_limit), best_value(nitems - 1, weight_limit - items[nitems - 1].weight) + items[nitems - 1].value) 
		for i in reversed(range(len(items))): 
			if best_value(i + 1, weight_limit) > best_value(i, weight_limit):  
				result.append(items[i]) 
				weight_limit -= items[i].weight 
		return result```
